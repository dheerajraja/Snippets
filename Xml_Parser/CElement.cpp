/* Generated by Together */

#include "CElement.h"
#include "CNode.h"
#include "CText.h"
#include <iomanip>		// Header für die Standard-IO-Objekte (z.B. cout, cin)/*#include <stdlib.h> //
 #include <string> // for string datatype,
 using namespace std;*/
CElement::CElement() :
		CNode(ELEMENT) // initializing parent class node type through parameter initialization list
{
	m_contentNodes = 0;

}

CElement::~CElement()
{
	for (int i = 0; i < m_contentNodes; i++)
	{

		delete[] (m_content[i]); // freeing the dynamic memory allocated for datastructure
		//cout<<"obj destroyed at"<<this<<endl;
	}
}

bool CElement::parseInput(const string& Input, unsigned& parsePosition)
{

	bool IsStartTag;
	string readtag;
	string::const_iterator it;			// initializing a string iterator
	it = Input.begin();

	//storing the tag of an element and to detect the start or end of tag.
	bool goodtag = parseStartOrEndTag(Input, parsePosition, IsStartTag,
			readtag);

	if (goodtag == true)
	{
		m_tag = readtag;// store m_tag only if it is a good tag else return error

	}
	else
	{
		return false;
	}

	while (IsStartTag == true)// while an endtag is not detected in an element keep iterating
	{
		if (it[parsePosition] == '<' && (it[parsePosition + 1] != '/'))	//encountering the start of a new element?
		{

			CElement* newelement;

			newelement = new CElement;// creating new element if an < is detected

			//cout<<"created at"<<this<<endl;
			bool addsuccess = addToContent((CNode*) newelement);// adding the child to the CNode datastructure

			if (addsuccess)
			{

				bool parsenewele = newelement->parseInput(Input, parsePosition);

				if (!parsenewele)			// upon parsing failure
				{
					return false;
				}

			}
			else			// upon adding if child to datastructure failure
			{
				return false;
			}

		}

		else if (it[parsePosition] != '<' && (it[parsePosition + 1] != '/'))// detecting text type data?
		{

			CText* newtext;

			newtext = new CText;// creating new text if neither < nor </  is detected
			//cout<<"created at"<<this<<endl;
			bool parsetext = newtext->parseInput(Input, parsePosition);

			if (parsetext == true)		// if text was suucessfully parsed
			{
				bool addsuccess = addToContent((CNode*) newtext);// adding the child to the CNode datastructure
				if (!addsuccess)// upon adding if child to datastructure failure
				{
					return false;

				}
			}
			else
				return false;
		}

		else //detecting an end tag if it is not a start tag or a text
		{
			bool goodendtag;
			goodendtag = parseStartOrEndTag(Input, parsePosition, IsStartTag,
					readtag);
			if (!goodendtag)
			{
				return false;

			}
		}

	}

	return true; // returning true upon successful parsing of an element
}

void CElement::print(int indent)
{
	int count = indent;

	while (count != 0) // for the right indenting
	{
		cout << " ";
		count--;
	}

	cout << "CElement" << "[m_tag=" << m_tag << "]" << endl;
	for (int i = 0; i < m_contentNodes; i++)
	{
		if (m_content[i]->getNodeType() == ELEMENT)
		{

			CElement* pd;
			pd = (CElement *) (m_content[i]);
			pd->print(2 + indent); // calling print function from child element and indenting 2 from every parent element

		}
		if (m_content[i]->getNodeType() == TEXT)
		{
			CText* pd;
			pd = (CText *) (m_content[i]);
			pd->print((2 + indent)); // calling print function from child text and indenting text by 2 from its element.

		}
	}
}

node_t CElement::getNodeType()
{
	return CNode::getNodeType();
}

bool CElement::addToContent(CNode* child)
{

	if (m_contentNodes > 9)
	{
		cout << "Max no. of nodes reached" << endl;
		return false;
	}
	else
	{

		m_content[m_contentNodes] = child;
		m_contentNodes++;

		return true;
	}
}
bool CElement::parseStartOrEndTag(const string& Input, unsigned& parsePosition,
		bool& IsStartTag, string& tag)
{

	string::const_iterator it;
	it = Input.begin();

	if ((it[parsePosition] == '<') && (it[parsePosition + 1] != '/')) // if it is the start tag of an element
	{
		parsePosition++;
		IsStartTag = true;
		while (it[parsePosition] != '>')
		{

			tag = tag + it[parsePosition];
			parsePosition++;
		}
		parsePosition++;

		std::size_t found = tag.find_first_of(":;'!@#$%^&*/()+\|"); // function returns npos if none of teh string elements were found in our input string
		std::size_t found1 = tag.find_first_of("0123456789-."); //gets the position where these characters were 1st found

		if ((found == std::string::npos) && (found1 != 0)) // if numeric,- &. were not found in 1st position of tag and dint contain special characters
		{

			return true; // good tag
		}
		else
		{
			return false; // bad tag
		}
	}

	if (it[parsePosition] == '<' && it[parsePosition + 1] == '/') // if it is the endtag of an element
	{
		string endtag;
		IsStartTag = false;
		parsePosition = parsePosition + 2; // tag is found after </
		while (it[parsePosition] != '>')
		{
			endtag = endtag + it[parsePosition];
			parsePosition++;

		}
		parsePosition++;

		if (endtag.compare(m_tag) != 0) //compare returns 0 if both strings are equal
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	return true;
}
